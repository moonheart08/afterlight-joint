using System.Numerics;
using Content.AL.UIKit;
using Content.AL.UIKit.Sheets;
using Content.AL.UIKit.Widgets;
using Content.Client.UserInterface.Controls;
using Content.Shared.Chat.Prototypes;
using Content.Shared.Speech;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.Graphics;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Player;
using Robust.Shared.Prototypes;
using static Robust.Client.UserInterface.StylesheetHelpers;
using static Content.AL.UIKit.ALStylesheetHelpers;
using ContainerButton = Robust.Client.UserInterface.Controls.ContainerButton;


namespace Content.Client.Chat.UI;

[GenerateTypedNameReferences]
public sealed partial class EmotesMenu : RadialMenu
{
    [Dependency] private readonly EntityManager _entManager = default!;
    [Dependency] private readonly IPrototypeManager _prototypeManager = default!;
    [Dependency] private readonly ISharedPlayerManager _playerManager = default!;

    private readonly SpriteSystem _spriteSystem;

    public event Action<ProtoId<EmotePrototype>>? OnPlayEmote;

    public EmotesMenu()
    {
        IoCManager.InjectDependencies(this);
        RobustXamlLoader.Load(this);

        _spriteSystem = _entManager.System<SpriteSystem>();

        var emotes = _prototypeManager.EnumeratePrototypes<EmotePrototype>();
        foreach (var emote in emotes)
        {
            var player = _playerManager.LocalSession?.AttachedEntity;
            if (emote.Category == EmoteCategory.Invalid ||
                emote.ChatTriggers.Count == 0 ||
                !(player.HasValue && (emote.Whitelist?.IsValid(player.Value, _entManager) ?? true)) ||
                (emote.Blacklist?.IsValid(player.Value, _entManager) ?? false))
                continue;

            if (!emote.Available &&
                _entManager.TryGetComponent<SpeechComponent>(player.Value, out var speech) &&
                !speech.AllowedEmotes.Contains(emote.ID))
                continue;

            // TODO: This is cringe and will break down the line.
            var parent = FindControl<OrbitalContainer>(emote.Category.ToString());

            var button = new EmoteMenuButton(emote, _spriteSystem, this);

            parent.AddChild(button);
            foreach (var child in Main.Children)
            {
                if (child is not RadialMenuTextureButton castChild)
                    continue;

                if (castChild.TargetLayer == emote.Category.ToString())
                {
                    castChild.Visible = true;
                    break;
                }
            }
        }
    }

    public void PlayEmote(ProtoId<EmotePrototype> emote)
    {
        OnPlayEmote?.Invoke(emote);
        Close();
    }
}


public sealed class EmoteMenuButton : ContainerButton
{
    public ProtoId<EmotePrototype> ProtoId { get; init; }

    public EmoteMenuButton(EmotePrototype emote, SpriteSystem spriteSystem, EmotesMenu parent)
    {
        ProtoId = emote.ID;

        var tex = new TextureRect
        {
            VerticalAlignment = VAlignment.Center,
            HorizontalAlignment = HAlignment.Center,
            Texture = spriteSystem.Frame0(emote.Icon),
            TextureScale = new Vector2(2f, 2f),
        };
        AddChild(tex);

        AddStyleClass("EmoteMenuButton");
        SetSize = new Vector2(64f, 64f);
        ToolTip = Loc.GetString(emote.Name);

        OnButtonUp += _ =>
        {
            parent.PlayEmote(ProtoId);
        };
    }
}

[Stylesheet]
public sealed class EmoteMenuStylesheet : BaseSubsheet
{
    public override StyleRule[] GetRules(BaseStyle origin)
    {
        return new StyleRule[]
        {
            // TODO: Replace with AL-style icons, instead of using random textures from the back room.
            E<TextureRect>().Class("EmoteMenuGeneralCategoryTexture")
                .Prop(TextureRect.StylePropertyTextureScale, new Vector2(2, 2))
                .Prop(TextureRect.StylePropertyTexture, origin.LoadTexture("/Textures/Clothing/Head/Soft/mimesoft.rsi/icon.png")),
            E<TextureRect>().Class("EmoteMenuVocalCategoryTexture")
                .Prop(TextureRect.StylePropertyTextureScale, new Vector2(2, 2))
                .Prop(TextureRect.StylePropertyTexture, origin.LoadTexture("/Textures/Interface/Emotes/vocal.png")),
            E<TextureRect>().Class("EmoteMenuHandsCategoryTexture")
                .Prop(TextureRect.StylePropertyTextureScale, new Vector2(2, 2))
                .Prop(TextureRect.StylePropertyTexture, origin.LoadTexture("/Textures/Clothing/Hands/Gloves/latex.rsi/icon.png")),
            E<RadialMenuButton>().Class("EmoteMenuButton").Class("EmoteMenu")
                .Prop(RadialMenuButton.StylePropertyStyleBox, new StyleBoxEmpty())
        };
    }
}
